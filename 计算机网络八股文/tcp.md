## TCP头格式

- 源端口，目标端口号
- 序列号
- 确认应答号
- 控制位：syn,ack,fin,rst

## 什么是TCP？

是**基于字节流，面向连接，可靠**的传输层协议

## 如何确定一个TCP连接？

源端口，源地址，目标端口，目标地址

## UDP和TCP的区别？

UDP是无连接的，效率高，不可靠。

UDP可以广播，TCP单播。

TCP有流量和拥塞控制，UDP没有

## UDP和TCP能用同一个端口号吗?

其实可以，因为UDP和TCP在协议栈是通过不同的内核进行处理的。

## TCP三次握手

- 客户端首先带着随机生成的seqNum 请求连接，把SYN标志位设置成1
- 服务端收到后，也随机生成自己的序列号，并把ack设置成收到的客户端seqNum+1，ack标志位和SYN都设置成1
- 客户端再次收到，把确认应答号设成收到的seqNum+1，发给服务端，并且这次可以带数据，ack标志位和SYN都设置成1，之后状态就一直是established状态
- 等到服务端接收，服务端的状态也修改为established，然后就能互相发送消息了。

## 为什么是三次握手，不是四次，两次？

> ~~三次握手才可以确定两个端都有收发能力~~

这样的理解是片面的

> 三次握手才能阻止历史连接重复

客户端发了两个报文，一个90，一个100，90的卡了。之后又恢复了，并且90的比100先到达服务端

服务器返回来的是91，但客户端这次连接想要的是101，所以把它丢弃了。

这样防止了历史连接重复初始化

### 如果两次握手会发生什么？

![两次握手无法阻止历史连接](https://cdn.xiaolincoding.com//mysql/other/fe898053d2e93abac950b1637645943f.png)


如果**只有两次握手，那么服务器端会发送多一次废的信息，并且浪费一次历史连接**，三次握手可以在服务器发送数据之前阻止掉历史连接。

## 那为什么不是四次？

三次就够了，四次浪费了。


TCP 建立连接时，通过三次握手**能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号**。序列号能够保证数据包不重复、不丢弃和按序传输。

不使用「两次握手」和「四次握手」的原因：

* 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
* 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数


## 有了MTU，为什么TCP还要设计MSS呢？

IP层中，MTU一般为1500个字节，MSS一般为1500减去TCP头和IP头的数据大小

![MTU 与 MSS](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230633447.png)

> ip层超过1500会进行分片，到达服务器之后组装起来再传递给TCP层，看起来十分井然有序*

**假如ip分片丢失一个，整个数据都要重传！。**

因为ip没有超时重传机制，所以需要用TCP的分片重传，这样可以大大提高效率。

**TCP建立连接时，需要确定双方MSS大小，然后进行分片，这样给ip层封装的时候就不需要再分片了，传递就算丢失某一个片，也可以只重传那个片**


## 什么是syn攻击？

TCP三次握手的过程，往往会伴随着半连接状态

**第一次握手的时候，连接信息会被加入半连接队列**

第三次握手成功，会新建一个对象加入全连接队列

假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的半连接队列**，使得服务端不能为正常用户服务。



## TCP断开过程-四次挥手

#### 四次挥手的过程是怎么样的？

1.客户端发送fin,状态变成fin_wait1

2.服务端受到，并且回复一个ack,代表**我知道你没东西发了，但是我可能还有东西要发！**。此时客户端变成Close_wait，服务端变成fin_wait

3.服务端处理完自己的东西，发送一个fin，并且状态变成Last_ACK

4.客户端收到了fin，并且回复一个ACK，期间进入**TIME_WAIT**,等待2MSL时间后，进入CLOSED状态，服务器在收到ACK后立马进入CLOSED。


## 为什么一定要四次挥手？握手却是三次？

服务端收到了客户端的Fin报文，代表客户端没话说了，不代表自己没话说。

**为什么握手是三次？**

三次握手可以抽象成为：

客户端：**我可以跟你说话吗？**

服务端：可以，那我可以跟你说话吗？

客户端：**可以**

其中，服务器端可以只发一条就，不浪口水

**四次挥手**


客户端：**我可以跟你挂了吗？**

服务端：可以

(服务端：“我还有话说...”)

服务端：**那我可以跟你挂了吗？**

客户端：**可以**

因为关闭连接的过程有可能伴随没处理完成的数据要返回，所以必须是四次。


## 为什么需要TIME_WAIT等待两个MSL时间？

1.因为2msl足以让两端的重传机制都废掉，从而可以断开连接彻底，还没有发送的数据包完全消失。

如果太快直接就关闭，那么服务器端假如建立了新的连接并且客户端的序列号和服务端旧报文对应的上，就会重传旧的数据。

2.可以优雅的关闭连接，否则服务端如果一直发送ack给客户端，但客户端都下线了，那你的实际关闭方式就是被TCP重传机制给关闭，不够优雅。
