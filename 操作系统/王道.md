# 进程

## 1 进程的组成

![img.png](asserts/img.png)

进程是运行的程序

进程包括PCB，程序段，数据段

进程的特性：动态，独立，异步。

## 进程的状态

- 就绪态
- 运行态
- 阻塞态

![img_1.png](asserts/img_1.png)

## 进程控制-用原语实现

![img_2.png](asserts/img_2.png)

本人回忆：

进程PCB包含了进程的所有信息

进程切换过程中需要保证原子性，否则会乱套，于是出现了原语

[](https://)

## 进程间通信
![img_3.png](asserts/img_3.png)
共享存储主要是共享一个内核中的空间，可以随意读写，但是需要加锁，否则会乱套
消息传递是PCB中维护一个消息队列，进程之间通过消息队列进行通信，分为两种模式
    - 直接通信 直接找进程并发送消息
    - 间接通信 通过发送给PCB中的一个“邮箱”，来传递消息，传输对象是邮箱，而不是进程
管道通信：管道是一种特殊的文件，可以实现进程间通信，但是只能实现单向通信，而且只能在有亲缘关系的进程间通信


## 线程概念
是进程的一部分，是CPU调度的基本单位，线程共享进程的资源，线程之间的切换比进程之间的切换快得多

## 线程的实现方式和多线程模型
- 用户级线程
    - 用户级线程通过模拟线程库来实现，线程库维护了线程的信息，线程的切换是通过线程库来实现的
- 内核级线程
    - 内核级线程是由操作系统来实现的，线程的切换是由操作系统来实现的
  
多线程模型：
- 多对一：多个用户级线程对应一个内核级线程。优点是实现简单，缺点是一个线程阻塞会导致所有线程阻塞
- 一对一：一个用户级线程对应一个内核级线程。优点是一个线程阻塞不会影响其他线程，缺点是线程切换开销大
- 多对多：多个用户级线程对应多个内核级线程。优点是兼顾了上面两种模型的优点，缺点是实现复杂

## 线程状态的转化
基本和进程没啥区别，通过TCB来实现线程的切换

## 处理机调度
![img_4.png](asserts/img_4.png)

自己回忆：
 处理机调度就是选一个程序将处理机分配给他
分为高级调度（作业）：选择合适的作业调入到内存
中级：选择合适的挂起的进程调入内存
低级：选择一个进程分配处理机

## 进程调度的时机
（似乎不是很重要 ）
![img_5.png](asserts/img_5.png)

## 调度器
调度器就是一个程序，用来实现进程调度。
闲逛进程：当没有进程需要执行时，调度器会选择一个闲逛进程执行，这个进程通常是一个空循环，用来消耗CPU时间，能耗特别低，访问0地址，不需要访存

## 调度评价标准
- CPU利用率：忙碌时间/总时间
- 吞吐量：单位时间内完成的作业
- 周转时间：作业完成时间-作业到达时间
- 等待时间：作业等待时间
![img_7.png](asserts/img_7.png)



## 调度算法（1）

![img_8.png](asserts/img_8.png)
**思想规则**
FCFS 先来先服务
SJF 短作业优先（如果是抢占式，则是剩余时间最短的优先）
HRRN 高相应比优先，响应比=（等待时间+服务时间）/服务时间，也就是说，长作业的等待时间越来越长的话，响应比就会越高。

## 调度算法（2）-交互式系统

![img_10.png](asserts/img_10.png)

- 时间片轮转：每个进程分配一个时间片，时间片用完后，进程被挂起，等待下一次调度
- 优先级调度：每个进程分配一个优先级，优先级高的先执行
- 多级反馈队列：多个队列，每个队列的时间片不同，优先级不同，每个队列的时间片是前一个队列的两倍，当一个队列的时间片用完后，进程被挂起，放到下一个队列中

## 调度算法3-多级队列调度算法


![img_9.png](asserts/img_9.png)


## 进程互斥
- 临界区：每个进程中访问共享资源的代码段
- 互斥：同一时间只能有一个进程访问临界区
- 同步：进程间的合作

互斥的四大原则：
- 空闲让进：如果临界区空闲，进程可以进入
- 忙则等待：忙的时候等待
- 有限等待：等待时间有限
- 让权等待：等待进程让出CPU


## 进程互斥的软件方法
![img_11.png](asserts/img_11.png)
单标执法：设置一个变量，当进程进入临界区时，将变量设置为1，当进程退出临界区时，将变量设置为0（表达一种意愿，谦让）
双标志位：设置两个标志，当每个标志指向true表示加上了锁（表达一种）
Peterson算法：两个进程，两个变量，一个表示进程是否进入临界区，一个表示是否有进程在等待进入临界区，通过这两个变量来实现进程的互斥


## 进程互斥的硬件方法
TSL指令：Test and Set Lock，原子操作，将锁设置为1，并返回原来的值
Swap指令：交换两个变量的值，原子操作
缺点：忙等待，浪费CPU时间，无法让权等待

## 信号量
信号量是一个整数，用来实现进程间的互斥和同步
P操作：信号量减1，如果信号量小于0，则进程阻塞
V操作：信号量加1，如果信号量小于等于0，则唤醒一个进程
![img_12.png](asserts/img_12.png)
分为两种
- 整形信号量 信号量的值是一个整数，缺点是无法解决进程间的同步问题，让权等待问题
- 复杂信号量 信号量里面维护一个等待队列，可以使得获取不到锁的进程进入等待队列，解决了让权等待问题

## 用信号量实现同步，互斥，前驱后继关系
同步是指两个进程之间有先后执行次序的关系，比如小明必须有烟才能思考
互斥是指两个进程之间不能同时执行，否则会有冲突，比如两个进程不能同时访问一个文件
前驱后继关系是指两个进程之间有先后执行次序的关系，比如小明必须等小红思考完才能思考，就是同步的复杂形式

## 生产者消费者问题
生产者消费者问题是一个经典的同步问题，生产者生产产品，消费者消费产品，生产者和消费者之间通过一个缓冲区来进行通信
当缓冲区满了，生产者就不能生产，当缓冲区空了，消费者就不能消费
我们可以定义两个信号量，生产者信号量用于表示还有多少空间可以生产，消费者信号量用于表示还有多少产品可以消费。
![img_13.png](asserts/img_13.png)

## 多消费者-单生产者问题
![img_14.png](asserts/img_14.png)

## 读者写者问题
读者写者问题是一个经典的同步问题，读者可以同时读，写者不能同时写，读者和写者之间通过一个缓冲区来进行通信
![img_15.png](asserts/img_15.png)

## 哲学家就餐问题
![img_16.png](asserts/img_16.png)
有三种解决思路：
- 一个哲学家同时拿起两个筷子
- 一个哲学家拿起左边的筷子，如果右边的筷子被拿走了，就放下左边的筷子

## 管程
管程是一种进程间通信的方式，管程是一个数据结构，里面包含了共享资源，以及对共享资源的操作，屏蔽了复杂的细节，提供了一种高级的抽象
管程的特点：
- 一个管程只能被一个进程访问
![img_17.png](asserts/img_17.png)
## 死锁
死锁是指两个或多个进程互相等待对方释放资源，导致所有进程都无法继续执行
![img_18.png](asserts/img_18.png)

## 预防死锁
![img_19.png](asserts/img_19.png)

## 避免死锁
避免死锁的方法是银行家算法，银行家算法是一种资源分配算法，通过判断当前系统的资源是否能满足进程的需求，来决定是否分配资源


![img_20.png](asserts/img_20.png)


## 死锁检测
资源分配图：是一种数据结构，用来表示系统中的资源分配情况
![img_21.png](asserts/img_21.png)
![img_22.png](asserts/img_22.png)
![img_23.png](asserts/img_23.png)


# 内存管理
## 内存基础知识（给跨考研的同学看的）
![img_24.png](asserts/img_24.png)

## 内存管理的基本功能（不太重要，只是一个概念）
![img_25.png](asserts/img_25.png)

## 两种内存扩充技术
- 交换技术：将进程从内存中调出，放到外存中，当需要的时候再调入内存
- 覆盖技术：将进程分为多个模块，每次只调入一个模块，当需要的时候再调入其他模块
- 还有一种叫做虚拟内存技术，虚拟内存技术是交换技术和覆盖技术的结合，虚拟内存技术的主要作用是将外存调入内存
内存扩充的作用：**可以让进程的大小超过物理内存的大小**
![img_26.png](asserts/img_26.png)

## 连续分配管理
- 单一连续分配：整个进程都在内存中
- 固定分区分配：将内存分为多个固定大小的区域，每个区域只能分配给一个进程
- 动态分区分配：将内存分为多个动态大小的区域，每个区域可以分配给多个进程
![img_27.png](asserts/img_27.png)

## 动态分区分配算法
**为了解决进程的内存空间具体放在哪里的问题**
![img_28.png](asserts/img_28.png)


## 分页内存管理
![img_29.png](asserts/img_29.png)

## 基本地址转换
- 逻辑地址：程序中的地址
- 物理地址：实际的地址
- 基本地址转换：将逻辑地址转换为物理地址
- 页表：用来存储逻辑地址和物理地址的映射关系
- 页表基址寄存器：存储页表的基址
- 页表长度寄存器：存储页表的长度
- 页表项：页表中的一个元素，存储逻辑地址和物理地址的映射关系
- 页内偏移：页内的偏移量
![img_30.png](asserts/img_30.png)


## TLB快表
> TLB是一个高速缓存，用来存储页表中的一部分，用来加速地址转换
![img_31.png](asserts/img_31.png)


## 二级页表
是为了解决页表项太多，内存装不下的问题。配合局部性原理，只需要将常用的页表项放在内存中，不常用的页表项放在外存中，节省空间

![img_32.png](asserts/img_32.png)


## 段式内存管理

![img_33.png](asserts/img_33.png)

![img_34.png](asserts/img_34.png)

## 段页氏管理
![img_35.png](asserts/img_35.png)

![img_36.png](asserts/img_36.png)

## 虚拟内存管理技术
![img_37.png](asserts/img_37.png)
虚拟内存的具体实现方式就是上面说的三种内存管理技术
区别是虚拟内存技术在这个基础上还要把外存调入内存，这样就可以实现进程的大小超过物理内存的大小

## 请求分页管理技术
内中断-缺页中断
![img_38.png](asserts/img_38.png)

![img_39.png](asserts/img_39.png)

## 最佳置换算法
![img_40.png](asserts/img_40.png)
## 先进先出置换算法
![img_41.png](asserts/img_41.png)
## 最近最久未使用置换算法
![img_42.png](asserts/img_42.png)
## 时钟置换算法
![img_43.png](asserts/img_43.png)
改进后的时钟置换算法
![img_45.png](asserts/img_45.png)

内存映射文件
![img.png](img.png)


# 文件管理

## 文件系统的基本功能
![img_1.png](img_1.png)
## 文件系统的逻辑结构
![img_2.png](img_2.png)
## 文件目录（十分重要）
![img_3.png](img_3.png)
## 文件的物理结构上
![img_4.png](img_4.png)
## 文件的物理结构下（非常重要）
![img_5.png](img_5.png)
汇总：![img_6.png](img_6.png)

## 文件的逻辑结构对比物理结构（很容易搞混！！）
![img_7.png](img_7.png)

## 文件空闲空间的分配与回收
![img_8.png](img_8.png)

## 文件的操作
![img_9.png](img_9.png)

## 文件的共享
![img_10.png](img_10.png)

## 文件的保护
![img_11.png](img_11.png)

## 文件的层次结构
![img_12.png](img_12.png)
![img_13.png](img_13.png)

## 文件的存储结构
![img_14.png](img_14.png)
## 文件系统的挂载
U盘

# IO设备
## IO分类
![img_15.png](img_15.png)

