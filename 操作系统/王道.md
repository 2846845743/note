# 进程

## 1 进程的组成

![img.png](img.png)

进程是运行的程序

进程包括PCB，程序段，数据段

进程的特性：动态，独立，异步。

## 进程的状态

- 就绪态
- 运行态
- 阻塞态

![img_1.png](img_1.png)

## 进程控制-用原语实现

![img_2.png](img_2.png)

本人回忆：

进程PCB包含了进程的所有信息

进程切换过程中需要保证原子性，否则会乱套，于是出现了原语

[](https://)

## 进程间通信
![img_3.png](img_3.png)
共享存储主要是共享一个内核中的空间，可以随意读写，但是需要加锁，否则会乱套
消息传递是PCB中维护一个消息队列，进程之间通过消息队列进行通信，分为两种模式
    - 直接通信 直接找进程并发送消息
    - 间接通信 通过发送给PCB中的一个“邮箱”，来传递消息，传输对象是邮箱，而不是进程
管道通信：管道是一种特殊的文件，可以实现进程间通信，但是只能实现单向通信，而且只能在有亲缘关系的进程间通信


## 线程概念
是进程的一部分，是CPU调度的基本单位，线程共享进程的资源，线程之间的切换比进程之间的切换快得多

## 线程的实现方式和多线程模型
- 用户级线程
    - 用户级线程通过模拟线程库来实现，线程库维护了线程的信息，线程的切换是通过线程库来实现的
- 内核级线程
    - 内核级线程是由操作系统来实现的，线程的切换是由操作系统来实现的
  
多线程模型：
- 多对一：多个用户级线程对应一个内核级线程。优点是实现简单，缺点是一个线程阻塞会导致所有线程阻塞
- 一对一：一个用户级线程对应一个内核级线程。优点是一个线程阻塞不会影响其他线程，缺点是线程切换开销大
- 多对多：多个用户级线程对应多个内核级线程。优点是兼顾了上面两种模型的优点，缺点是实现复杂

## 线程状态的转化
基本和进程没啥区别，通过TCB来实现线程的切换

## 处理机调度
![img_4.png](img_4.png)

自己回忆：
 处理机调度就是选一个程序将处理机分配给他
分为高级调度（作业）：选择合适的作业调入到内存
中级：选择合适的挂起的进程调入内存
低级：选择一个进程分配处理机

## 进程调度的时机
（似乎不是很重要 ）
![img_5.png](img_5.png)

## 调度器
调度器就是一个程序，用来实现进程调度。
闲逛进程：当没有进程需要执行时，调度器会选择一个闲逛进程执行，这个进程通常是一个空循环，用来消耗CPU时间，能耗特别低，访问0地址，不需要访存

## 调度评价标准
- CPU利用率：忙碌时间/总时间
- 吞吐量：单位时间内完成的作业
- 周转时间：作业完成时间-作业到达时间
- 等待时间：作业等待时间
![img_7.png](img_7.png)



## 调度算法（1）

![img_8.png](img_8.png)
**思想规则**
FCFS 先来先服务
SJF 短作业优先（如果是抢占式，则是剩余时间最短的优先）
HRRN 高相应比优先，响应比=（等待时间+服务时间）/服务时间，也就是说，长作业的等待时间越来越长的话，响应比就会越高。

## 调度算法（2）-交互式系统

![img_10.png](img_10.png)

- 时间片轮转：每个进程分配一个时间片，时间片用完后，进程被挂起，等待下一次调度
- 优先级调度：每个进程分配一个优先级，优先级高的先执行
- 多级反馈队列：多个队列，每个队列的时间片不同，优先级不同，每个队列的时间片是前一个队列的两倍，当一个队列的时间片用完后，进程被挂起，放到下一个队列中

## 调度算法3-多级队列调度算法


![img_9.png](img_9.png)





























