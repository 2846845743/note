# 约束篇

主键约束

1.单列主键：使某一列字段的值不允许重复。不允许为null

2.复合主键：使某些字段复合之后的值不允许同时重复。

3.自动增长约束（有默认值但非空）：
在字段后面加上AUTO_INCREMENT 可以设置默认值

```
create table if not exists zidingyi(
   id int primary key auto_increment,
   name varchar(20),
   salary double
)auto_increment=666; 
```

4 .delete删除和trunsate删除的区别：
delete from table;是将数据库一行一行删除，删除完之后如果再进行插入，那么自增操作将会接着没删除以前的最后一行数据继续自增。

5 trunsate是直接删除整张表之后再重新创建一张表，所以插入数据不会继续自增，且设定的初始值会失效。trunsate删除效率很高且不可以回滚，delete操作可以进行回滚。

6.已经创建的表如何添加约束？

Alter table xxx add constraint xxx unique(字段)
非空约束：在字段后面加上NOT NULL 可以使字段不能为空
唯一约束：在字段后加上UNIQUE KEY 使这个字段唯一（允许为null，且null可以重复）

默认约束：在字段后面加上default ''默认值''

零填充约束：规定了长度的字段，如果不满长度则从左边补000.

# 索引篇

索引概述：索引是一种查询效率极高的数据结构。
索引结构：B树，有序存放，中间分裂。
B+树，有序存放，中间分裂，且叶子结点形成双向链表，大大提升效            率
hash结构：类似于java的hashTable，由数组加链表实现，查询效率极高，但是增删改效率很低。

索引分类：
聚集索引：必须有且只有一个，将数据与索引存放到一起，索引结构的叶子存放了行数据
二级索引：数据和索引分开储存，关联的是对应的主键。可以存在多个
（如果有主键，则主键索引就是聚集索引。如果没有主键，用第一个唯一索引作为聚集索引。如果再没有，将自动生成一个rowid作为隐藏的聚集索引。）
（三层高度的b+树可以存放2千万行的数据。）

### 索引语法

```
#!mysql
//创建索引
create 分类 index  索引名称  on 表 (关联的字段);
查看索引
show index from 表;
删除索引
drop index 名称 on 表;
性能分析：
查看执行频次：
show global status like 'Com__'
慢表查询：
需要先开启配置文件
show variables like '   '后重启mysql
show profile详情：
select @@profiling;
```

### 索引使用原则

1.联合索引中最左前缀法制。指的是索引最左边的列一定要存在，且不得跳过中间的列，不然部分索引失效。

2.范围查询的右边索引失效。一般加上等于号来规避这个问题。

3.不要在索引列上进行运算操作，否则索引失效。字符串不加引号索引失效。尾部模糊匹配索引正常，头部模糊匹配索引失效。

4.用 or 链接的条件，只有两边都存在索引时索引才会生效

5.sql提示：在索引使用时可以加use index  ignore index  force index来表示建议使用，忽视，强制使用xx索引。

6.覆盖索引：如果查询条件是二级索引，但是需要返回的数据包含其他没有索引的字段，就会发生回表查询，效率变低很多。举例：
有一个sql，如何江他优化？select id,passwd,username from user where username="whh";
答：将passwd和username建立一个联合二级索引，这样可以避免回表查询。

7.前缀索引：截取字符串的前几个字符当作索引，降低磁盘空间的大小。
选择性：不重复的记录条数/记录总数的比值，越接近1越高效。

8.联合索引？单列索引？一般用联合索引更好。

### 索引设计原则

1.数据量大，查询频繁需要索引

2.常作为where，orderby，group by的字段建立索引

3.区分度较高的建立索引

4.字符串使用前缀索引(考虑区分度）

5.使用联合索引，减少单列索引（需要遵循最左前缀法
制）

6.控制索引数量，否则大大影响增删改的效率

7.如果索引不能储存NULL请在NOT NULL来约束他。

### sql优化

1.插入数据：批量插入    手动提交事务      主键顺序插入大批量插入数据，可以用load指令插入

2.主键优化：顺序插入主键，效率更高。

3.排序优化：？？？

4.分组优化：使用索引，遵循最左前缀法则

5.limit优化：使用limit时到后面数据分页效率会变得
很低，所以推荐使用子查询+索引。

6.count优化 ：优先使用count *

7.update优化：尽量用主键或者索引字段进行更行。

# MySQL锁篇

- 全局锁：锁住整个数据库，不能进行写入操作。利于数据备份
- .表锁：
  - 读锁：加上之后只能读，自己也不能写。
  - 写锁：自己能读能写，其他客户端不能读不能写。
- 行锁： 锁住一行数据，其他客户端不能读不能写。分为三种：间隙锁，记录锁，临键锁。

# 事务篇

### MVCC

MVCC是mysql的一个专业术语（多版本并发控制），用于解决多个并发事务同时操作一个数据时，另一个新事务读取到哪个版本的问题。

对于不同的隔离级别，mvcc机制会有不同的效果

例如在rc（读已提交）的隔离级别下，事务每一次操作都会产生一个快照读（readView）
在rr（可重复读）的隔离级别下，事务只有在第一次开启事务时生成一个快照读（readView），后续所有操作都用同一个快照读。

### 快照读vs当前读

当前读是用mysql锁机制来实现的，读的时候不可以写，写的时候不可以读，保证每一次读的数据都是最新的。快照读可以读到未提交的数据，读写并不冲突。
readView包含几个字段：当前活跃事务ids列表，活跃事务最小id，活跃事务最大id+1，还有一个是生成当前readView的事务id。读取规则如下：

# 日志篇

### MYSQL日志

- binlog：二进制日志，用于存放mysql的全量数据，默认有三种格式
  - 1.statement：将sql语句记录下来
  - 2.row：记录每一行的数据的变化，这样方便映射，但是确定是会造成日志文件过大
  - 3.mixed：混合
  - errorlog：错误日志。用于查看mysql系统报错
  - 慢查询日志：默认是关闭的，需要设置一下，可以指定“超过几秒钟”的sql会记录在慢查询日志里

### 主从同步的原理

1 MySQL主节点将修改后的数据都记录在binLog，从节点会启动一个ioThread去读取binlog中的数据，然后写到自己的中继日志SQLLog里，再开启线程读取这个SqlLog映射到自己的库里面。并且mysql不会同步全量数据，如果需要第一次就同步完全，需要mysqlDump自己手动同步原有数据。

### 数据不一致问题

假设以下场景：事务A已经在表1插入了4个数据，事务B想要在表2创建一样的数据，此时事务A和B一起对表2进行操作，那么在事务B中可能执行插入了ID为1，2，4，5的数据，事务A插入了3.这看起来好像没什么问题，但是事务B记录的主键是不连续的，也就是造成了binlog主键不连续。（要么先记录A，要么先记录B）
binLog一旦不连续，从库读取的数据也就不一致了
解决方案：通过设置binLog的格式为row，这样binlog设置的是行记录的变化，而不是设置5条sql语句让从库执行。

### Mysql死锁问题的产生

如果两个事务同时执行了一条select for update语句，然后获取了两个间隙锁，那么晚接下来两个插入insert语句：A执行插入1007，因为B有间隙锁所以会被阻塞。B准备插入1008，因为A有获得间隙锁所以被阻塞，两个事务都在等待对方提交释放间隙锁，所以造成了死锁。

如何避免死锁？
死锁必要条件：互斥，占有等待，不可强占用，循环等待。

- 设置事务等待锁的超时时间
- 开启主动死锁检测
